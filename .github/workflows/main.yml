# Name des Workflows
name: Build Android APK with BeeWare Briefcase

# Trigger für den Workflow
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    # Der Job läuft auf der neuesten Ubuntu-Version
    runs-on: ubuntu-latest

    steps:
    # 1. Repository auschecken
    - name: Repository auschecken
      uses: actions/checkout@v4

    # 2. Python-Umgebung einrichten
    - name: Python einrichten
      uses: actions/setup-python@v5
      with:
        python-version: '3.9' # Oder Ihre bevorzugte Python-Version

    # 3. Java Development Kit (JDK) einrichten (für Android SDK, von Briefcase benötigt)
    - name: Java JDK einrichten (für Android SDK)
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    # 4. Briefcase installieren
    - name: Briefcase installieren
      run: |
        python -m pip install --upgrade pip
        pip install briefcase

    # 5. Bereite App-Struktur vor und erstelle die Android APK
    - name: Bereite App-Struktur vor und erstelle die Android APK
      run: |
        # Briefcase erwartet, dass Ihre App ein Python-Paket ist.
        # Wenn Ihr Projekt nicht bereits so strukturiert ist,
        # erstellen wir hier ein Beispielpaket 'mypythonapp'.
        #
        # WICHTIG: Im echten Projekt sollten Sie diese Verzeichnisstruktur
        # (z.B. 'mypythonapp/__init__.py', 'mypythonapp/main.py')
        # in Ihrem Git-Repository haben!
        
        APP_PACKAGE_DIR="mypythonapp" # Muss dem App-Namen in pyproject.toml entsprechen
        
        # Erstelle das Paketverzeichnis, falls es nicht existiert
        mkdir -p "$APP_PACKAGE_DIR"
        
        # Erstelle eine leere __init__.py, falls nicht vorhanden (macht es zu einem Python-Paket)
        if [ ! -f "$APP_PACKAGE_DIR/__init__.py" ]; then
            touch "$APP_PACKAGE_DIR/__init__.py"
        fi
        
        # Verschiebe oder erstelle main.py im Paketverzeichnis, falls notwendig
        # (passen Sie dies an, wenn Ihre main.py woanders ist oder anders heißt)
        if [ ! -f "$APP_PACKAGE_DIR/main.py" ]; then
            echo "print('Hallo von meiner BeeWare Android App!')" > "$APP_PACKAGE_DIR/main.py"
        fi

        # Erstellen/Aktualisieren Sie die pyproject.toml-Datei im Root Ihres Repositorys.
        # Passen Sie die Werte für Ihre tatsächliche App an.
        cat <<EOF > pyproject.toml
        [project]
        name = "MyPythonApp"
        version = "1.0.0"
        description = "Eine einfache Python-App, gebaut mit BeeWare Briefcase."
        requires-python = ">=3.9"
        # Korrigierte Lizenzdefinition nach PEP 621
        license = { file = "LICENSE" } # Geht davon aus, dass es eine LICENSE-Datei gibt

        [tool.briefcase]
        project_name = "MyPythonApp"
        bundle = "org.example" # Ihre eindeutige Paket-ID (z.B. com.ihrefirma)
        author = "Ihr Name"
        author_email = "ihre.email@example.com"
        url = "https://example.com/mypythonapp"
        # Die 'license'-Definition unter [tool.briefcase] wird ignoriert, wenn [project].license existiert.
        # Sie können sie hier trotzdem lassen, wenn Sie möchten, aber es ist redundant.
        license = "MIT" # Redundant, da [project].license gesetzt ist.
        requires = [] # Fügen Sie hier Ihre Python-Abhängigkeiten hinzu (z.B. ["kivy", "requests"])

        [tool.briefcase.app.mypythonapp] # Der Name hier muss dem 'project.name' entsprechen (kleingeschrieben und Bindestriche statt Leerzeichen)
        # sources zeigt auf das Verzeichnis, das das App-Paket enthält.
        # Da 'mypythonapp' direkt im Root liegt, ist sources = ["."] weiterhin korrekt.
        sources = ["."] 
        # main_module ist jetzt der Name des Pakets (mypythonapp), da Briefcase den Einstiegspunkt
        # als mypythonapp.__main__ oder mypythonapp.main erwartet.
        main_module = "mypythonapp" # Name des Pakets, nicht der Datei!
        long_description = "Eine ausführlichere Beschreibung Ihrer Anwendung."
        
        [tool.briefcase.app.mypythonapp.android]
        target_device = "generic" # Kann auch "Pixel 4" oder andere sein
        sdk_version = "34" # Die Android API-Level, auf das Sie abzielen
        min_sdk_version = "21" # Die minimale Android API-Level, die Ihre App unterstützt
        build_tools_version = "34.0.0" # Die Android Build Tools Version
        supported_abis = ["arm64-v8a"] # Ziel-Architekturen. arm64-v8a ist für moderne Geräte üblich.
        # permissions = ["android.permission.INTERNET"] # Optional: Fügen Sie hier benötigte Android-Berechtigungen hinzu
        EOF

        # Optional: Erstelle eine leere LICENSE-Datei, wenn nicht vorhanden,
        # um die Lizenzwarnung zu vermeiden.
        if [ ! -f LICENSE ]; then
            echo "Copyright (c) $(date +%Y) Ihr Name" > LICENSE
            echo "" >> LICENSE
            echo "MIT License" >> LICENSE
            echo "" >> LICENSE
            echo "Permission is hereby granted, free of charge, to any person obtaining a copy" >> LICENSE
            echo "of this software and associated documentation files (the \"Software\"), to deal" >> LICENSE
            echo "in the Software without restriction, including without limitation the rights" >> LICENSE
            echo "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell" >> LICENSE
            echo "copies of the Software, and to permit persons to whom the Software is" >> LICENSE
            echo "furnished to do so, subject to the following conditions:" >> LICENSE
            echo "" >> LICENSE
            echo "The above copyright notice and this permission notice shall be included in all" >> LICENSE
            echo "copies or substantial portions of the Software." >> LICENSE
            echo "" >> LICENSE
            echo "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR" >> LICENSE
            echo "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY," >> LICENSE
            echo "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE" >> LICENSE
            echo "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER" >> LICENSE
            echo "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM," >> LICENSE
            echo "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE" >> LICENSE
            echo "SOFTWARE." >> LICENSE
        fi


        echo "Starte den Briefcase-Build für Android..."
        # Briefcase build android wird bei Bedarf automatisch briefcase create und SDK-Installationen verwalten.
        briefcase build android

        # Briefcase platziert die APKs typischerweise in einem Unterordner wie 'android/gradle/MyPythonApp/app/build/outputs/apk/debug/'.
        # Wir suchen die generierte APK-Datei.
        APK_PATH=$(find android -name "*.apk" | head -n 1)
        if [ -z "$APK_PATH" ]; then
            echo "FEHLER: APK-Datei nicht gefunden. Überprüfen Sie die Briefcase-Ausgabe auf Fehler."
            exit 1
        fi
        echo "APK erfolgreich erstellt unter: $APK_PATH"
        echo "APK_PATH=$APK_PATH" >> $GITHUB_ENV # Setzt die Umgebungsvariable für den Upload

    # 6. Erstelltes APK als Artefakt hochladen
    - name: APK-Artefakt hochladen
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: App-Debug-APK
        path: ${{ env.APK_PATH }} # Verwendet den dynamisch gefundenen Pfad
        retention-days: 7
        
