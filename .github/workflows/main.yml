# Name des Workflows
name: Build Android APK with BeeWare Briefcase

# Trigger für den Workflow
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    # Der Job läuft auf der neuesten Ubuntu-Version
    runs-on: ubuntu-latest

    steps:
    # 1. Repository auschecken
    - name: Repository auschecken
      uses: actions/checkout@v4

    # 2. Python-Umgebung einrichten
    - name: Python einrichten
      uses: actions/setup-python@v5
      with:
        python-version: '3.9' # Oder Ihre bevorzugte Python-Version

    # 3. Java Development Kit (JDK) einrichten (für Android SDK, von Briefcase benötigt)
    - name: Java JDK einrichten (für Android SDK)
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    # 4. Briefcase installieren
    - name: Briefcase installieren
      run: |
        set -e
        echo "Aktualisiere pip und installiere eine spezifische Version von briefcase (0.3.17)..."
        python -m pip install --upgrade pip
        # KORREKTUR: Installiere die spezifische Version 0.3.17 von Briefcase
        pip install briefcase==0.3.17 
        echo "Briefcase-Installation abgeschlossen."
        briefcase --version # Überprüfen, welche Version installiert wurde

    # 5. Bereite App-Struktur vor und erstelle die Android APK
    - name: Bereite App-Struktur vor und erstelle die Android APK
      run: |
        set -e
        
        echo "--- START: Vorbereitung der App-Struktur und pyproject.toml ---"
        echo "Aktuelles Arbeitsverzeichnis: $(pwd)"
        echo "Benutzer: $(whoami)"

        # Entferne Buildozer-spezifische und andere potenziell störende Dateien
        if [ -f "buildozer.spec" ]; then
            echo "Entferne 'buildozer.spec'."
            rm "buildozer.spec" || { echo "FEHLER: Konnte 'buildozer.spec' nicht entfernen."; exit 1; }
        fi
        if [ -f "main_apk.py" ]; then
            echo "Entferne 'main_apk.py'."
            rm "main_apk.py" || { echo "FEHLER: Konnte 'main_apk.py' nicht entfernen."; exit 1; }
        fi
        if [ -f "projekt.toml" ]; then
            echo "Entferne 'projekt.toml'."
            rm "projekt.toml" || { echo "FEHLER: Konnte 'projekt.toml' nicht entfernen."; exit 1; }
        fi


        # Definiere das Stammverzeichnis für den App-Quellcode
        APP_SOURCE_ROOT="src" 
        # Definiere den Namen des Python-Paket-Ordners (innerhalb von APP_SOURCE_ROOT)
        APP_PACKAGE_NAME="mypythonapp" 
        APP_PACKAGE_PATH="$APP_SOURCE_ROOT/$APP_PACKAGE_NAME"

        # 1. Erstelle das Haupt-Quellverzeichnis und das Python-Paket-Verzeichnis
        echo "Erstelle Quellverzeichnis: $APP_SOURCE_ROOT"
        mkdir -p "$APP_SOURCE_ROOT" || { echo "FEHLER: Konnte Verzeichnis $APP_SOURCE_ROOT nicht erstellen."; exit 1; }
        
        echo "Erstelle Paketverzeichnis: $APP_PACKAGE_PATH"
        mkdir -p "$APP_PACKAGE_PATH" || { echo "FEHLER: Konnte Verzeichnis $APP_PACKAGE_PATH nicht erstellen."; exit 1; }
        
        # 2. Erstelle eine leere __init__.py, falls nicht vorhanden (macht es zu einem Python-Paket)
        echo "Erstelle __init__.py in $APP_PACKAGE_PATH/__init__.py"
        if [ ! -f "$APP_PACKAGE_PATH/__init__.py" ]; then
            touch "$APP_PACKAGE_PATH/__init__.py" || { echo "FEHLER: Konnte __init__.py nicht erstellen."; exit 1; }
        fi
        
        # 3. Erstelle main.py im Paketverzeichnis, falls notwendig
        echo "Erstelle main.py in $APP_PACKAGE_PATH/main.py"
        if [ ! -f "$APP_PACKAGE_PATH/main.py" ]; then
            echo "print('Hallo von meiner BeeWare Android App!')" > "$APP_PACKAGE_PATH/main.py" || { echo "FEHLER: Konnte main.py nicht erstellen."; exit 1; }
        fi

        # 4. Optional: Erstelle eine leere LICENSE-Datei, wenn nicht vorhanden,
        # um die Lizenzwarnung zu vermeiden.
        echo "Erstelle/prüfe LICENSE-Datei..."
        if [ ! -f LICENSE ]; then
            echo "Copyright (c) $(date +%Y) Ihr Name" > LICENSE
            echo "" >> LICENSE
            echo "MIT License" >> LICENSE
            echo "" >> LICENSE
            echo "Permission is hereby granted, free of charge, to any person obtaining a copy" >> LICENSE
            echo "of this software and associated documentation files (the \"Software\"), to deal" >> LICENSE
            echo "in the Software without restriction, including without limitation the rights" >> LICENSE
            echo "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell" >> LICENSE
            echo "copies of the Software, and to permit persons to whom the Software is" >> LICENSE
            echo "furnished to do so, subject to the following conditions:" >> LICENSE
            echo "" >> LICENSE
            echo "The above copyright notice and this permission notice shall be included in all" >> LICENSE
            echo "copies or substantial portions of the Software." >> LICENSE
            echo "" >> LICENSE
            echo "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR" >> LICENSE
            echo "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY," >> LICENSE
            echo "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE" >> LICENSE
            echo "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER" >> LICENSE
            echo "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM," >> LICENSE
            echo "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE" >> LICENSE
            echo "SOFTWARE." >> LICENSE
            echo "LICENSE-Datei wurde erstellt."
        else
            echo "LICENSE-Datei existiert bereits."
        fi

        # 5. Erstelle die pyproject.toml-Datei mit aktualisierten 'sources'-Pfaden.
        echo "Generiere pyproject.toml mit aktualisierten Inhalten..."
        cat <<EOF > pyproject.toml
        [project]
        name = "MyPythonApp"
        version = "1.0.0"
        description = "Eine einfache Python-App, gebaut mit BeeWare Briefcase."
        requires-python = ">=3.9"
        license = { file = "LICENSE" } # PEP 621 Lizenzdefinition

        [tool.briefcase]
        project_name = "MyPythonApp"
        bundle = "org.example" 
        author = "Ihr Name"
        author_email = "ihre.email@example.com"
        url = "https://example.com/mypythonapp"
        requires = [] 

        [tool.briefcase.app.mypythonapp] 
        sources = ["src/mypythonapp"] 
        main_module = "main" 
        long_description = "Eine ausführlichere Beschreibung Ihrer Anwendung."
        
        [tool.briefcase.app.mypythonapp.android]
        target_device = "generic"
        sdk_version = "34" 
        min_sdk_version = "21"
        build_tools_version = "34.0.0"
        supported_abis = ["arm64-v8a"]
        build_gradle_dependencies = [
            "androidx.appcompat:appcompat:1.0.2",
            "androidx.constraintlayout:constraintlayout:1.1.3",
            "androidx.swiperefreshlayout:swiperefreshlayout:1.1.0",
        ]
        # KORREKTUR: Erzwinge die Vorlagenversion, die mit Briefcase 0.3.17 kompatibel ist.
        template = "https://github.com/beeware/briefcase-android-gradle-template.git#v0.3.17"
        permissions = []
        EOF
        echo "pyproject.toml wurde generiert."

        echo "--- DEBUGGING-AUSGABE: Dateistruktur und pyproject.toml Inhalt (vor Briefcase-Aufruf) ---"
        echo "Inhalt von pyproject.toml:"
        cat pyproject.toml
        echo "Dateistruktur im aktuellen Verzeichnis:"
        ls -F
        echo "Rekursive Dateistruktur ab dem aktuellen Verzeichnis:"
        ls -R
        echo "--- ENDE DEBUGGING-AUSGABE ---"

        # Cache löschen und Build starten
        echo "Lösche Briefcase-Cache und Build-Verzeichnisse für einen sauberen Start..."
        rm -rf ~/.briefcase || { echo "Warnung: Konnte ~/.briefcase nicht löschen."; }
        rm -rf build || { echo "Warnung: Konnte 'build/' Verzeichnis nicht löschen."; }
        rm -rf android || { echo "Warnung: Konnte 'android/' Verzeichnis nicht löschen."; } 
        echo "Briefcase-Cache und temporäre Build-Artefakte gelöscht."
        
        echo "Starte den Briefcase-Build für Android..."
        briefcase build android 

        echo "Suche nach der generierten APK-Datei..."
        APK_PATH=$(find android -name "*.apk" -print -quit) 
        
        if [ -z "$APK_PATH" ]; then
            echo "FEHLER: APK-Datei nicht gefunden. Überprüfen Sie die Briefcase-Ausgabe auf Fehler."
            exit 1
        fi
        echo "APK erfolgreich erstellt unter: $APK_PATH"
        echo "APK_PATH=$APK_PATH" >> $GITHUB_ENV # Setzt die Umgebungsvariable für den Upload
        echo "--- ENDE: Vorbereitung und Build ---"

    # 6. Erstelltes APK als Artefakt hochladen
    - name: APK-Artefakt hochladen
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: App-Debug-APK
        path: ${{ env.APK_PATH }} # Verwendet den dynamisch gefundenen Pfad
        retention-days: 7
        
