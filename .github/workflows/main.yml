# Name des Workflows
name: Android APK mit BeeWare Briefcase bauen

# Trigger für den Workflow
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Ermöglicht das manuelle Starten des Workflows über die GitHub Actions UI

jobs:
  build:
    # Der Job läuft auf der neuesten Ubuntu-Version
    runs-on: ubuntu-latest

    steps:
    # 1. Repository auschecken
    - name: Repository auschecken
      uses: actions/checkout@v4

    # 2. Python-Umgebung einrichten
    - name: Python einrichten
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    # 3. Java Development Kit (JDK) einrichten (für Android SDK, von Briefcase benötigt)
    - name: Java JDK einrichten (für Android SDK)
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    # 4. Briefcase installieren (NEU: Spezifische ältere Version)
    - name: Briefcase installieren
      run: |
        set -e # Beendet das Skript sofort, wenn ein Befehl fehlschlägt
        echo "Aktualisiere pip und installiere eine ältere, spezifische Version von briefcase (0.3.14)."
        python -m pip install --upgrade pip
        # Installiert Briefcase Version 0.3.14, die bekanntermaßen stabil war und den TypeError vermeiden sollte.
        pip install briefcase==0.3.14
        echo "Briefcase-Installation abgeschlossen."
        briefcase --version # Überprüfen, welche Version installiert wurde

    # 5. Bereite App-Struktur vor und erstelle die Android APK
    - name: Bereite App-Struktur vor und erstelle die Android APK
      run: |
        set -e # Beendet das Skript sofort, wenn ein Befehl fehlschlägt
        
        echo "--- START: Vorbereitung der App-Struktur und pyproject.toml ---"
        echo "Aktuelles Arbeitsverzeichnis: $(pwd)"
        echo "Benutzer: $(whoami)"

        # Lösche alte Konfigurationsdateien, die Briefcase verwirren könnten
        if [ -f "buildozer.spec" ]; then rm "buildozer.spec" || { echo "FEHLER: Konnte 'buildozer.spec' nicht entfernen."; }; fi
        if [ -f "main_apk.py" ]; then rm "main_apk.py" || { echo "FEHLER: Konnte 'main_apk.py' nicht entfernen."; }; fi
        if [ -f "project.toml" ]; then
            echo "Entferne 'project.toml'."
            rm "project.toml" || { echo "FEHLER: Konnte 'project.toml' nicht entfernen."; }
        fi

        # Verzeichnisse für die App-Struktur erstellen
        APP_SOURCE_ROOT="src" 
        APP_PACKAGE_NAME="mypythonapp" 
        APP_PACKAGE_PATH="$APP_SOURCE_ROOT/$APP_PACKAGE_NAME"

        mkdir -p "$APP_SOURCE_ROOT" || { echo "FEHLER: Konnte Verzeichnis $APP_SOURCE_ROOT nicht erstellen."; exit 1; }
        mkdir -p "$APP_PACKAGE_PATH" || { echo "FEHLER: Konnte Verzeichnis $APP_PACKAGE_PATH nicht erstellen."; exit 1; }
        
        # Leere __init__.py und einfache main.py erstellen
        if [ ! -f "$APP_PACKAGE_PATH/__init__.py" ]; then touch "$APP_PACKAGE_PATH/__init__.py" || { echo "FEHLER: Konnte __init__.py nicht erstellen."; exit 1; }; fi
        if [ ! -f "$APP_PACKAGE_PATH/main.py" ]; then echo "print('Hallo von meiner BeeWare Android App!')" > "$APP_PACKAGE_PATH/main.py" || { echo "FEHLER: Konnte main.py nicht erstellen."; exit 1; }; fi

        echo "Erstelle/prüfe LICENSE-Datei..."
        if [ ! -f LICENSE ]; then
            cat <<EOL > LICENSE
Copyright (c) $(date +%Y) Ihr Name

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOL
            echo "LICENSE-Datei wurde erstellt."
        else
            echo "LICENSE-Datei existiert bereits."
        fi

        echo "Generiere pyproject.toml mit aktualisierten Inhalten..."
        # HIER IST DIE KORREKTUR: KEINE ZUSÄTZLICHEN LEERZEICHEN VOR DEN ZEILEN IM <<EOF-BLOCK!
        cat <<EOF > pyproject.toml
[project]
name = "MyPythonApp"
version = "1.0.0"
description = "Eine einfache Python-App, gebaut mit BeeWare Briefcase."
requires-python = ">=3.9"
license = { file = "LICENSE" } # PEP 621 Lizenzdefinition

[tool.briefcase]
project_name = "MyPythonApp"
bundle = "org.example" 
author = "Ihr Name"
author_email = "ihre.email@example.com"
url = "https://example.com/mypythonapp"
requires = [] 

[tool.briefcase.app.mypythonapp] 
sources = ["src/mypythonapp"] 
main_module = "main" 
long_description = "Eine ausführlichere Beschreibung Ihrer Anwendung."

[tool.briefcase.app.mypythonapp.android]
target_device = "generic"
sdk_version = "34" 
min_sdk_version = "21"
build_tools_version = "34.0.0"
supported_abis = ["arm64-v8a"]
build_gradle_dependencies = [
    "androidx.appcompat:appcompat:1.0.2",
    "androidx.constraintlayout:constraintlayout:1.1.3",
    "androidx.swiperefreshlayout:swiperefreshlayout:1.1.0",
]
permissions = []
EOF
        echo "pyproject.toml wurde generiert."

        echo "--- DEBUGGING-AUSGABE: Dateistruktur und pyproject.toml Inhalt (vor Briefcase-Aufruf) ---"
        echo "Inhalt von pyproject.toml:"
        cat pyproject.toml
        echo "Dateistruktur im aktuellen Verzeichnis:"
        ls -F
        echo "Rekursive Dateistruktur ab dem aktuellen Verzeichnis:"
        ls -R
        echo "--- ENDE DEBUGGING-AUSGABE ---"

        # Briefcase-Cache und Build-Verzeichnisse für einen sauberen Start löschen
        echo "Lösche Briefcase-Cache und Build-Verzeichnisse für einen sauberen Start..."
        rm -rf ~/.briefcase || { echo "Warnung: Konnte ~/.briefcase nicht löschen."; }
        rm -rf build || { echo "Warnung: Konnte 'build/' Verzeichnis nicht löschen."; }
        rm -rf android || { echo "Warnung: Konnte 'android/' Verzeichnis nicht löschen."; } 
        echo "Briefcase-Cache und temporäre Build-Artefakte gelöscht."
        
        echo "Starte den Briefcase-Build für Android..."
        # Briefcase 0.3.14 sollte den TypeError vermeiden.
        briefcase build android --update
        
        echo "Suche nach der generierten APK-Datei..."
        APK_PATH=$(find android -name "*.apk" -print -quit) # Findet die erste gefundene APK
        
        if [ -z "$APK_PATH" ]; then
            echo "FEHLER: APK-Datei nicht gefunden. Überprüfen Sie die Briefcase-Ausgabe auf Fehler."
            exit 1
        fi
        echo "APK erfolgreich erstellt unter: $APK_PATH"
        echo "APK_PATH=$APK_PATH" >> $GITHUB_ENV # Setzt die Umgebungsvariable für den Upload-Schritt
        echo "--- ENDE: Vorbereitung und Build ---"

    # 6. Erstelltes APK als Artefakt hochladen
    - name: APK-Artefakt hochladen
      uses: actions/upload-artifact@v4
      if: always() # Läuft immer, auch wenn vorherige Schritte fehlschlagen, um Logs hochzuladen
      with:
        name: App-Debug-APK
        path: ${{ env.APK_PATH }} # Verwendet den dynamisch gefundenen Pfad
        retention-days: 7
        
